(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[918],{3905:function(e,a,r){"use strict";r.d(a,{Zo:function(){return c},kt:function(){return d}});var n=r(7294);function t(e,a,r){return a in e?Object.defineProperty(e,a,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[a]=r,e}function i(e,a){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var a=1;a<arguments.length;a++){var r=null!=arguments[a]?arguments[a]:{};a%2?i(Object(r),!0).forEach((function(a){t(e,a,r[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(r,a))}))}return e}function l(e,a){if(null==e)return{};var r,n,t=function(e,a){if(null==e)return{};var r,n,t={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],a.indexOf(r)>=0||(t[r]=e[r]);return t}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],a.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(t[r]=e[r])}return t}var s=n.createContext({}),u=function(e){var a=n.useContext(s),r=a;return e&&(r="function"==typeof e?e(a):o(o({},a),e)),r},c=function(e){var a=u(e.components);return n.createElement(s.Provider,{value:a},e.children)},p={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},y=n.forwardRef((function(e,a){var r=e.components,t=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),y=u(r),d=t,f=y["".concat(s,".").concat(d)]||y[d]||p[d]||i;return r?n.createElement(f,o(o({ref:a},c),{},{components:r})):n.createElement(f,o({ref:a},c))}));function d(e,a){var r=arguments,t=a&&a.mdxType;if("string"==typeof e||t){var i=r.length,o=new Array(i);o[0]=y;var l={};for(var s in a)hasOwnProperty.call(a,s)&&(l[s]=a[s]);l.originalType=e,l.mdxType="string"==typeof e?e:t,o[1]=l;for(var u=2;u<i;u++)o[u]=r[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}y.displayName="MDXCreateElement"},7434:function(e,a,r){"use strict";r.r(a),r.d(a,{frontMatter:function(){return o},metadata:function(){return l},toc:function(){return s},default:function(){return c}});var n=r(2122),t=r(9756),i=(r(7294),r(3905)),o={sidebar_position:2},l={unversionedId:"api/data-array",id:"api/data-array",isDocsHomePage:!1,title:"Data Arrays",description:"The general abstraction for lists of results in Dataview is the DataArray, which is a proxied array with additional",source:"@site/docs/api/data-array.md",sourceDirName:"api",slug:"/api/data-array",permalink:"/obsidian-dataview/docs/api/data-array",version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"sidebar",previous:{title:"Overview",permalink:"/obsidian-dataview/docs/api/intro"},next:{title:"Codeblock Reference",permalink:"/obsidian-dataview/docs/api/code-reference"}},s=[{value:"Creation",id:"creation",children:[]},{value:"Indexing and Swizzling",id:"indexing-and-swizzling",children:[]},{value:"Raw Interface",id:"raw-interface",children:[]}],u={toc:s};function c(e){var a=e.components,r=(0,t.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,n.Z)({},u,r,{components:a,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The general abstraction for lists of results in Dataview is the ",(0,i.kt)("inlineCode",{parentName:"p"},"DataArray"),", which is a proxied array with additional\nfunctionality. Data arrays support indexing and iteration (via ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"for ... of")," loops) as per normal arrays, but\nalso include many data manipulation operators like ",(0,i.kt)("inlineCode",{parentName:"p"},"sort"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"groupBy"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"distinct"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"where"),", and so on to make\nmainpulating tabular data easy."),(0,i.kt)("h2",{id:"creation"},"Creation"),(0,i.kt)("p",null,"Data arrays are returned by most Dataview APIs that can return multiple results, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"dv.pages()"),". You can also\nexplicitly convert a normal JavaScript array into a Dataview array using ",(0,i.kt)("inlineCode",{parentName:"p"},"dv.array(<array>)"),". If you want to convert a\nData array back to a normal array, use ",(0,i.kt)("inlineCode",{parentName:"p"},"DataArray#array()"),"."),(0,i.kt)("h2",{id:"indexing-and-swizzling"},"Indexing and Swizzling"),(0,i.kt)("p",null,"Data arrays support regular indexing just like normal arrays (like ",(0,i.kt)("inlineCode",{parentName:"p"},"array[0]"),'), but importantly, they also support\nquery-language-style "swizzling": if you index into a data array with a field name (like ',(0,i.kt)("inlineCode",{parentName:"p"},"array.field"),"), it\nautomatically maps every element in the array to ",(0,i.kt)("inlineCode",{parentName:"p"},"field"),", flattening ",(0,i.kt)("inlineCode",{parentName:"p"},"field")," if it itself is also an array."),(0,i.kt)("p",null,"For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"dv.pages().file.name")," will return a data array of all file names in your vault;\n",(0,i.kt)("inlineCode",{parentName:"p"},'dv.pages("#books").genres')," will return a flattened list of all genres in your books."),(0,i.kt)("h2",{id:"raw-interface"},"Raw Interface"),(0,i.kt)("p",null,"The full interface for the data array implementation is provided below for reference:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"/** A function which maps an array element to some value. */\nexport type ArrayFunc<T, O> = (elem: T, index: number, arr: T[]) => O;\n\n/** A function which compares two types (plus their indices, if relevant). */\nexport type ArrayComparator<T> = (a: T, b: T) => number;\n\n/**\n * Proxied interface which allows manipulating array-based data. All functions on a data array produce a NEW array\n * (i.e., the arrays are immutable).\n */\nexport interface DataArray<T> {\n    /** The total number of elements in the array. */\n    length: number;\n\n    /** Filter the data array down to just elements which match the given predicate. */\n    where(predicate: ArrayFunc<T, boolean>): DataArray<T>;\n    /** Alias for 'where' for people who want array semantics. */\n    filter(predicate: ArrayFunc<T, boolean>): DataArray<T>;\n\n    /** Map elements in the data array by applying a function to each. */\n    map<U>(f: ArrayFunc<T, U>): DataArray<U>;\n    /** Map elements in the data array by applying a function to each, then flatten the results to produce a new array. */\n    flatMap<U>(f: ArrayFunc<T, U[]>): DataArray<U>;\n    /** Mutably change each value in the array, returning the same array which you can further chain off of. */\n    mutate(f: ArrayFunc<T, any>): DataArray<any>;\n\n    /** Limit the total number of entries in the array to the given value. */\n    limit(count: number): DataArray<T>;\n    /**\n     * Take a slice of the array. If `start` is undefined, it is assumed to be 0; if `end` is undefined, it is assumbed\n     * to be the end of the array.\n     */\n    slice(start?: number, end?: number): DataArray<T>;\n\n    /**\n     * Return a sorted array sorted by the given key; an optional comparator can be provided, which will\n     * be used to compare the keys in leiu of the default dataview comparator.\n     */\n    sort<U>(key: ArrayFunc<T, U>, direction?: 'asc' | 'desc', comparator?: ArrayComparator<U>): DataArray<T>;\n\n    /**\n     * Return an array where elements are grouped by the given key; the resulting array will have objects of the form\n     * { key: <key value>, rows: DataArray }.\n     */\n    groupBy<U>(key: ArrayFunc<T, U>, comparator?: ArrayComparator<U>): DataArray<{ key: U, rows: DataArray<T> }>;\n\n    /**\n     * Return distinct entries. If a key is provided, then rows with distinct keys are returned.\n     */\n    distinct<U>(key?: ArrayFunc<T, U>, comparator?: ArrayComparator<U>): DataArray<T>;\n\n    /** Return true if the predicate is true for all values. */\n    every(f: ArrayFunc<T, boolean>): boolean;\n    /** Return true if the predicate is true for at least one value. */\n    some(f: ArrayFunc<T, boolean>): boolean;\n    /** Return true if the predicate is FALSE for all values. */\n    none(f: ArrayFunc<T, boolean>): boolean;\n\n    /** Return the first element in the data array. Returns undefined if the array is empty. */\n    first(): T;\n    /** Return the last element in the data array. Returns undefined if the array is empty. */\n    last(): T;\n\n    /** Map every element in this data array to the given key, and then flatten it.*/\n    to(key: string): DataArray<any>;\n    /**\n     * Recursively expand the given key, flattening a tree structure based on the key into a flat array. Useful for handling\n     * heirarchical data like tasks with 'subtasks'.\n     */\n    expand(key: string): DataArray<any>;\n\n    /** Run a lambda on each element in the array. */\n    forEach(f: ArrayFunc<T, void>): void;\n\n    /** Convert this to a plain javascript array. */\n    array(): T[];\n\n    /** Allow iterating directly over the array. */\n    [Symbol.iterator](): Iterator<T>;\n\n    /** Map indexes to values. */\n    [index: number]: any;\n    /** Automatic flattening of fields. */\n    [field: string]: any;\n}\n")))}c.isMDXComponent=!0}}]);